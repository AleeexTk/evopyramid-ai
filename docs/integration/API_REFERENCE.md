# Quantum Context Engine API Reference

## High-level Helpers

### `enhanced_respond`

```python
async def enhanced_respond(query: str, existing_context: Optional[Dict[str, Any]] = None) -> str
```

- `query` – user query text.
- `existing_context` – optional context dictionary from host systems.
- Returns a formatted string generated by the selected pipeline.

### `get_context_engine`

```python
def get_context_engine() -> EvoCodexContextEngine
```

Returns a singleton instance of the context engine.

### `quick_analyze`

```python
async def quick_analyze(query: str) -> Dict[str, Any]
```

Returns an abbreviated analysis without generating a final response.

## EvoCodexContextEngine

### `process_query`

```python
async def process_query(self, query: str, user_context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]
```

Result payload:

```python
{
    "success": bool,
    "response": str,
    "context": Dict[str, Any],
    "processing_time": float,
    "priority_path": str,
}
```

### `get_stats`

```python
def get_stats(self) -> Dict[str, Any]
```

Returns aggregated statistics such as total queries, path distribution, and average processing time.

### `add_to_memory`

```python
async def add_to_memory(self, fragment_data: Dict[str, Any]) -> Dict[str, Any]
```

`fragment_data` parameters:

- `id` (optional) – unique identifier; generated when omitted.
- `name` – fragment title.
- `content` – fragment body.
- `type` – memory layer (`core`, `functional`, `emotional`, `meta`).
- `weight` – importance weight between 0 and 1.
- `emotional_tone` (optional) – descriptive label.

## QuantumContextAnalyzer

### `analyze`

```python
async def analyze(self) -> Dict[str, Any]
```

Returns:

```python
{
    "intent": {"urgency": float, "type": str, "confidence": float},
    "affect": {"soul_resonance": float, "emotion": str, "intensity": float},
    "memory": {"has_strong_links": bool, "fragments": List[str], "relevance_score": float},
}
```

All metrics are derived from deterministic keyword heuristics, ensuring identical
results for identical queries across runs.

### `analyze_and_respond`

```python
async def analyze_and_respond(query: str) -> str
```

Returns a formatted response string using the automatically selected pipeline.

## PyramidMemory

### `find_relevant_fragments`

```python
def find_relevant_fragments(self, query: str, threshold: float = 0.6) -> List[MemoryFragment]
```

Returns up to five fragments ordered by relevance and weight.

### `add_fragment`

```python
def add_fragment(self, fragment: MemoryFragment) -> None
```

Adds or updates a fragment in the XML store and persists the change.

## Data Classes

### `MemoryFragment`

```python
@dataclass
class MemoryFragment:
    id: str
    name: str
    content: str
    memory_type: str
    weight: float
    timestamp: str
    emotional_tone: Optional[str] = None
    links: List[str] = field(default_factory=list)
    relevance_score: float = 0.0
```

### `IntentResult`

```python
@dataclass
class IntentResult:
    urgency: float
    type: str
    confidence: float
```

### `AffectResult`

```python
@dataclass
class AffectResult:
    soul_resonance: float
    emotion: str
    intensity: float
```

### `MemoryResult`

```python
@dataclass
class MemoryResult:
    has_strong_links: bool
    fragments: List[str]
    relevance_score: float
```
